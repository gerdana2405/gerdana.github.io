"use strict";
var chalk = require('chalk');
var minimist = require('minimist');
var path = require('path');
var main_1 = require('./main');
// Examples:
//
// ```sh
// # Generate one declaration file
// ts-api-guardian --out api_guard.d.ts index.d.ts
//
// # Generate multiple declaration files // # (output location like typescript)
// ts-api-guardian --outDir api_guard [--rootDir .] core/index.d.ts core/testing.d.ts
//
// # Print usage
// ts-api-guardian --help
//
// # Check against one declaration file
// ts-api-guardian --verify api_guard.d.ts index.d.ts
//
// # Check against multiple declaration files
// ts-api-guardian --verifyDir api_guard [--rootDir .] core/index.d.ts core/testing.d.ts
// ```
var CMD = 'ts-api-guardian';
function startCli() {
    var _a = parseArguments(process.argv.slice(2)), argv = _a.argv, mode = _a.mode, errors = _a.errors;
    var options = {
        stripExportPattern: argv['stripExportPattern'],
        allowModuleIdentifiers: [].concat(argv['allowModuleIdentifiers']),
        onStabilityMissing: argv['onStabilityMissing'] || 'none'
    };
    if (['warn', 'error', 'none'].indexOf(options.onStabilityMissing) < 0) {
        throw new Error('Argument for "--onStabilityMissing" option must be one of: "warn", "error", "none"');
    }
    for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
        var error = errors_1[_i];
        console.warn(error);
    }
    if (mode === 'help') {
        printUsageAndExit(!!errors.length);
    }
    else {
        var targets = generateFileNamePairs(argv, mode);
        if (mode === 'out') {
            for (var _b = 0, targets_1 = targets; _b < targets_1.length; _b++) {
                var _c = targets_1[_b], entrypoint = _c.entrypoint, goldenFile = _c.goldenFile;
                main_1.generateGoldenFile(entrypoint, goldenFile, options);
            }
        }
        else {
            var hasDiff = false;
            for (var _d = 0, targets_2 = targets; _d < targets_2.length; _d++) {
                var _e = targets_2[_d], entrypoint = _e.entrypoint, goldenFile = _e.goldenFile;
                var diff = main_1.verifyAgainstGoldenFile(entrypoint, goldenFile, options);
                if (diff) {
                    hasDiff = true;
                    var lines = diff.split('\n');
                    if (lines.length) {
                        lines.pop(); // Remove trailing newline
                    }
                    for (var _f = 0, lines_1 = lines; _f < lines_1.length; _f++) {
                        var line = lines_1[_f];
                        var chalkMap = { '-': chalk.red, '+': chalk.green, '@': chalk.cyan };
                        var chalkFunc = chalkMap[line[0]] || chalk.reset;
                        console.log(chalkFunc(line));
                    }
                }
            }
            if (hasDiff) {
                process.exit(1);
            }
        }
    }
}
exports.startCli = startCli;
function parseArguments(input) {
    var help = false;
    var errors = [];
    var argv = minimist(input, {
        string: [
            'out', 'outDir', 'verify', 'verifyDir', 'rootDir', 'stripExportPattern',
            'allowModuleIdentifiers', 'onStabilityMissing'
        ],
        boolean: [
            'help',
            // Options used by chalk automagically
            'color', 'no-color'
        ],
        alias: { 'outFile': 'out', 'verifyFile': 'verify' },
        unknown: function (option) {
            if (option[0] === '-') {
                errors.push("Unknown option: " + option);
                help = true;
                return false; // do not add to argv._
            }
            else {
                return true; // add to argv._
            }
        }
    });
    help = help || argv['help'];
    if (help) {
        return { argv: argv, mode: 'help', errors: errors };
    }
    var modes = [];
    if (argv['out']) {
        modes.push('out');
    }
    if (argv['outDir']) {
        modes.push('out');
    }
    if (argv['verify']) {
        modes.push('verify');
    }
    if (argv['verifyDir']) {
        modes.push('verify');
    }
    if (!argv._.length) {
        errors.push('No input file specified.');
        modes = ['help'];
    }
    else if (modes.length !== 1) {
        errors.push('Specify either --out[Dir] or --verify[Dir]');
        modes = ['help'];
    }
    else if (argv._.length > 1 && !argv['outDir'] && !argv['verifyDir']) {
        errors.push("More than one input specified. Use --" + modes[0] + "Dir instead.");
        modes = ['help'];
    }
    return { argv: argv, mode: modes[0], errors: errors };
}
exports.parseArguments = parseArguments;
function printUsageAndExit(error) {
    if (error === void 0) { error = false; }
    var print = error ? console.warn.bind(console) : console.log.bind(console);
    print("Usage:  " + CMD + " [options] <file ...>\n        " + CMD + " --out <output file> <entrypoint .d.ts file>\n        " + CMD + " --outDir <output dir> [--rootDir .] <entrypoint .d.ts files>\n\n        " + CMD + " --verify <golden file> <entrypoint .d.ts file>\n        " + CMD + " --verifyDir <golden file dir> [--rootDir .] <entrypoint .d.ts files>\n\nOptions:\n        --help                          Show this usage message\n\n        --out <file>                    Write golden output to file\n        --outDir <dir>                  Write golden file structure to directory\n\n        --verify <file>                 Read golden input from file\n        --verifyDir <dir>               Read golden file structure from directory\n\n        --rootDir <dir>                 Specify the root directory of input files\n\n        --stripExportPattern <regexp>   Do not output exports matching the pattern\n        --allowModuleIdentifiers <identifier>\n                                        Whitelist identifier for \"* as foo\" imports\n        --onStabilityMissing <warn|error|none>\n                                        Warn or error if an export has no stability\n                                        annotation");
    process.exit(error ? 1 : 0);
}
function generateFileNamePairs(argv, mode) {
    if (argv[mode]) {
        return [{ entrypoint: argv._[0], goldenFile: argv[mode] }];
    }
    else {
        var rootDir_1 = argv['rootDir'] || '.';
        var goldenDir_1 = argv[mode + 'Dir'];
        return argv._.map(function (fileName) {
            return {
                entrypoint: fileName,
                goldenFile: path.join(goldenDir_1, path.relative(rootDir_1, fileName))
            };
        });
    }
}
exports.generateFileNamePairs = generateFileNamePairs;

//# sourceMappingURL=cli.js.map
