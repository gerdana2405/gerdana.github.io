"use strict";
var path = require('path');
var ts = require('typescript');
var baseTsOptions = {
    // We don't want symbols from external modules to be resolved, so we use the
    // classic algorithm.
    moduleResolution: ts.ModuleResolutionKind.Classic
};
function publicApi(fileName, options) {
    if (options === void 0) { options = {}; }
    return publicApiInternal(ts.createCompilerHost(baseTsOptions), fileName, baseTsOptions, options);
}
exports.publicApi = publicApi;
function publicApiInternal(host, fileName, tsOptions, options) {
    if (options === void 0) { options = {}; }
    var entrypoint = path.normalize(fileName);
    if (!entrypoint.match(/\.d\.ts$/)) {
        throw new Error("Source file \"" + fileName + "\" is not a declaration file");
    }
    var program = ts.createProgram([entrypoint], tsOptions, host);
    return new ResolvedDeclarationEmitter(program, entrypoint, options).emit();
}
exports.publicApiInternal = publicApiInternal;
var ResolvedDeclarationEmitter = (function () {
    function ResolvedDeclarationEmitter(program, fileName, options) {
        this.program = program;
        this.fileName = fileName;
        this.options = options;
        this.diagnostics = [];
        this.typeChecker = this.program.getTypeChecker();
    }
    ResolvedDeclarationEmitter.prototype.emit = function () {
        var _this = this;
        var sourceFile = this.program.getSourceFiles().filter(function (sf) { return sf.fileName === _this.fileName; })[0];
        if (!sourceFile) {
            throw new Error("Source file \"" + this.fileName + "\" not found");
        }
        var output = '';
        var resolvedSymbols = this.getResolvedSymbols(sourceFile);
        // Sort all symbols so that the output is more deterministic
        resolvedSymbols.sort(symbolCompareFunction);
        for (var _i = 0, resolvedSymbols_1 = resolvedSymbols; _i < resolvedSymbols_1.length; _i++) {
            var symbol = resolvedSymbols_1[_i];
            if (this.options.stripExportPattern && symbol.name.match(this.options.stripExportPattern)) {
                continue;
            }
            var decl = symbol.valueDeclaration || symbol.declarations && symbol.declarations[0];
            if (!decl) {
                this.diagnostics.push({
                    type: 'warning',
                    message: sourceFile.fileName + ": error: No declaration found for symbol \"" + symbol.name + "\""
                });
                continue;
            }
            // The declaration node may not be a complete statement, e.g. for var/const
            // symbols. We need to find the complete export statement by traversing
            // upwards.
            while (!(decl.flags & ts.NodeFlags.Export) && decl.parent) {
                decl = decl.parent;
            }
            if (decl.flags & ts.NodeFlags.Export) {
                // Make an empty line between two exports
                if (output) {
                    output += '\n';
                }
                // Print stability annotation
                var sourceText = decl.getSourceFile().text;
                var trivia = sourceText.substr(decl.pos, decl.getLeadingTriviaWidth());
                var match = stabilityAnnotationPattern.exec(trivia);
                if (match) {
                    output += "/** @" + match[1] + " */\n";
                }
                else if (['warn', 'error'].indexOf(this.options.onStabilityMissing) >= 0) {
                    this.diagnostics.push({
                        type: this.options.onStabilityMissing,
                        message: createErrorMessage(decl, "No stability annotation found for symbol \"" + symbol.name + "\"")
                    });
                }
                output += stripEmptyLines(this.emitNode(decl)) + '\n';
            }
            else {
                // This may happen for symbols re-exported from external modules.
                this.diagnostics.push({
                    type: 'warning',
                    message: createErrorMessage(decl, "No export declaration found for symbol \"" + symbol.name + "\"")
                });
            }
        }
        if (this.diagnostics.length) {
            var message = this.diagnostics.map(function (d) { return d.message; }).join('\n');
            console.warn(message);
            if (this.diagnostics.some(function (d) { return d.type === 'error'; })) {
                throw new Error(message);
            }
        }
        return output;
    };
    ResolvedDeclarationEmitter.prototype.getResolvedSymbols = function (sourceFile) {
        var _this = this;
        var ms = sourceFile.symbol;
        var rawSymbols = ms ? (this.typeChecker.getExportsOfModule(ms) || []) : [];
        return rawSymbols.map(function (s) {
            if (s.flags & ts.SymbolFlags.Alias) {
                var resolvedSymbol = _this.typeChecker.getAliasedSymbol(s);
                // This will happen, e.g. for symbols re-exported from external modules.
                if (!resolvedSymbol.valueDeclaration && !resolvedSymbol.declarations) {
                    return s;
                }
                if (resolvedSymbol.name !== s.name) {
                    if (_this.options.stripExportPattern && s.name.match(_this.options.stripExportPattern)) {
                        return s;
                    }
                    throw new Error(("Symbol \"" + resolvedSymbol.name + "\" was aliased as \"" + s.name + "\". ") +
                        "Aliases are not supported.\"");
                }
                return resolvedSymbol;
            }
            else {
                return s;
            }
        });
    };
    ResolvedDeclarationEmitter.prototype.emitNode = function (node) {
        var _this = this;
        if (node.flags & ts.NodeFlags.Private) {
            return '';
        }
        var firstQualifier = getFirstQualifier(node);
        if (firstQualifier) {
            if (!this.options.allowModuleIdentifiers ||
                this.options.allowModuleIdentifiers.indexOf(firstQualifier.text) < 0) {
                this.diagnostics.push({
                    type: 'error',
                    message: createErrorMessage(firstQualifier, ("Module identifier \"" + firstQualifier.text + "\" is not allowed. Remove it ") +
                        "from source or whitelist it via --allowModuleIdentifiers.")
                });
            }
        }
        var children = node.getChildren();
        var sourceText = node.getSourceFile().text;
        if (children.length) {
            // Sort declarations under a class or an interface
            if (node.kind === ts.SyntaxKind.SyntaxList) {
                switch (node.parent && node.parent.kind) {
                    case ts.SyntaxKind.ClassDeclaration:
                    case ts.SyntaxKind.InterfaceDeclaration: {
                        // There can be multiple SyntaxLists under a class or an interface,
                        // since SyntaxList is just an arbitrary data structure generated
                        // by Node#getChildren(). We need to check that we are sorting the
                        // right list.
                        if (children.every(function (node) { return node.kind in memberDeclarationOrder; })) {
                            children = children.slice();
                            children.sort(function (a, b) {
                                // Static after normal
                                return compareFunction(a.flags & ts.NodeFlags.Static, b.flags & ts.NodeFlags.Static) ||
                                    // Our predefined order
                                    compareFunction(memberDeclarationOrder[a.kind], memberDeclarationOrder[b.kind]) ||
                                    // Alphebetical order
                                    // We need safe dereferencing due to edge cases, e.g. having two call signatures
                                    compareFunction((a.name || a).getText(), (b.name || b).getText());
                            });
                        }
                        break;
                    }
                }
            }
            var output = children.map(function (n) { return _this.emitNode(n); }).join('');
            // Print stability annotation for fields
            if (node.kind in memberDeclarationOrder) {
                var trivia = sourceText.substr(node.pos, node.getLeadingTriviaWidth());
                var match = stabilityAnnotationPattern.exec(trivia);
                if (match) {
                    // Add the annotation after the leading whitespace
                    output = output.replace(/^(\n\s*)/, "$1/** @" + match[1] + " */ ");
                }
            }
            return output;
        }
        else {
            var ranges = ts.getLeadingCommentRanges(sourceText, node.pos);
            var tail = node.pos;
            for (var _i = 0, _a = ranges || []; _i < _a.length; _i++) {
                var range = _a[_i];
                if (range.end > tail) {
                    tail = range.end;
                }
            }
            return sourceText.substring(tail, node.end);
        }
    };
    return ResolvedDeclarationEmitter;
}());
function symbolCompareFunction(a, b) {
    return a.name.localeCompare(b.name);
}
function compareFunction(a, b) {
    return a === b ? 0 : a > b ? 1 : -1;
}
var memberDeclarationOrder = (_a = {},
    _a[ts.SyntaxKind.PropertySignature] = 0,
    _a[ts.SyntaxKind.PropertyDeclaration] = 0,
    _a[ts.SyntaxKind.GetAccessor] = 0,
    _a[ts.SyntaxKind.SetAccessor] = 0,
    _a[ts.SyntaxKind.CallSignature] = 1,
    _a[ts.SyntaxKind.Constructor] = 2,
    _a[ts.SyntaxKind.ConstructSignature] = 2,
    _a[ts.SyntaxKind.IndexSignature] = 3,
    _a[ts.SyntaxKind.MethodSignature] = 4,
    _a[ts.SyntaxKind.MethodDeclaration] = 4,
    _a
);
var stabilityAnnotationPattern = /@(experimental|stable|deprecated)\b/;
function stripEmptyLines(text) {
    return text.split('\n').filter(function (x) { return !!x.length; }).join('\n');
}
/**
 * Returns the first qualifier if the input node is a dotted expression.
 */
function getFirstQualifier(node) {
    if (node.kind === ts.SyntaxKind.PropertyAccessExpression) {
        // For expression position
        var lhs = node;
        do {
            lhs = lhs.expression;
        } while (lhs && lhs.kind !== ts.SyntaxKind.Identifier);
        return lhs;
    }
    else if (node.kind === ts.SyntaxKind.TypeReference) {
        // For type position
        var lhs = node.typeName;
        do {
            lhs = lhs.left;
        } while (lhs && lhs.kind !== ts.SyntaxKind.Identifier);
        return lhs;
    }
    else {
        return null;
    }
}
function createErrorMessage(node, message) {
    var sourceFile = node.getSourceFile();
    var position;
    if (sourceFile) {
        var _a = sourceFile.getLineAndCharacterOfPosition(node.getStart()), line = _a.line, character = _a.character;
        position = sourceFile.fileName + "(" + (line + 1) + "," + (character + 1) + ")";
    }
    else {
        position = '<unknown>';
    }
    return position + ": error: " + message;
}
var _a;

//# sourceMappingURL=serializer.js.map
