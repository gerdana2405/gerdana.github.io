{"version":3,"sources":["serializer.ts"],"names":[],"mappings":"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","file":"serializer.js","sourcesContent":["import * as path from 'path';\nimport * as ts from 'typescript';\n\nconst baseTsOptions: ts.CompilerOptions = {\n  // We don't want symbols from external modules to be resolved, so we use the\n  // classic algorithm.\n  moduleResolution: ts.ModuleResolutionKind.Classic\n};\n\nexport interface SerializationOptions {\n  /**\n   * Removes all exports matching the regular expression.\n   */\n  stripExportPattern?: RegExp;\n  /**\n   * Whitelists these identifiers as modules in the output. For example,\n   * ```\n   * import * as angular from './angularjs';\n   *\n   * export class Foo extends angular.Bar {}\n   * ```\n   * will produce `export class Foo extends angular.Bar {}` and requires\n   * whitelisting angular.\n   */\n  allowModuleIdentifiers?: string[];\n  /**\n   * Warns or errors if stability annotations are missing on an export.\n   * Supports experimental, stable and deprecated.\n   */\n  onStabilityMissing?: string;  // 'warn' | 'error' | 'none'\n}\n\nexport function publicApi(fileName: string, options: SerializationOptions = {}): string {\n  return publicApiInternal(ts.createCompilerHost(baseTsOptions), fileName, baseTsOptions, options);\n}\n\nexport function publicApiInternal(\n    host: ts.CompilerHost, fileName: string, tsOptions: ts.CompilerOptions,\n    options: SerializationOptions = {}): string {\n  const entrypoint = path.normalize(fileName);\n\n  if (!entrypoint.match(/\\.d\\.ts$/)) {\n    throw new Error(`Source file \"${fileName}\" is not a declaration file`);\n  }\n\n  const program = ts.createProgram([entrypoint], tsOptions, host);\n  return new ResolvedDeclarationEmitter(program, entrypoint, options).emit();\n}\n\ninterface Diagnostic {\n  type: string;  // 'warning' | 'error'\n  message: string;\n}\n\nclass ResolvedDeclarationEmitter {\n  private program: ts.Program;\n  private fileName: string;\n  private typeChecker: ts.TypeChecker;\n  private options: SerializationOptions;\n  private diagnostics: Diagnostic[];\n\n  constructor(program: ts.Program, fileName: string, options: SerializationOptions) {\n    this.program = program;\n    this.fileName = fileName;\n    this.options = options;\n    this.diagnostics = [];\n\n    this.typeChecker = this.program.getTypeChecker();\n  }\n\n  emit(): string {\n    const sourceFile = this.program.getSourceFiles().filter(sf => sf.fileName === this.fileName)[0];\n    if (!sourceFile) {\n      throw new Error(`Source file \"${this.fileName}\" not found`);\n    }\n\n    let output = '';\n\n    const resolvedSymbols = this.getResolvedSymbols(sourceFile);\n    // Sort all symbols so that the output is more deterministic\n    resolvedSymbols.sort(symbolCompareFunction);\n\n    for (const symbol of resolvedSymbols) {\n      if (this.options.stripExportPattern && symbol.name.match(this.options.stripExportPattern)) {\n        continue;\n      }\n\n      let decl: ts.Node = symbol.valueDeclaration || symbol.declarations && symbol.declarations[0];\n      if (!decl) {\n        this.diagnostics.push({\n          type: 'warning',\n          message: `${sourceFile.fileName}: error: No declaration found for symbol \"${symbol.name}\"`\n        });\n        continue;\n      }\n\n      // The declaration node may not be a complete statement, e.g. for var/const\n      // symbols. We need to find the complete export statement by traversing\n      // upwards.\n      while (!(decl.flags & ts.NodeFlags.Export) && decl.parent) {\n        decl = decl.parent;\n      }\n      if (decl.flags & ts.NodeFlags.Export) {\n        // Make an empty line between two exports\n        if (output) {\n          output += '\\n';\n        }\n\n        // Print stability annotation\n        const sourceText = decl.getSourceFile().text;\n        const trivia = sourceText.substr(decl.pos, decl.getLeadingTriviaWidth());\n        const match = stabilityAnnotationPattern.exec(trivia);\n        if (match) {\n          output += `/** @${match[1]} */\\n`;\n        } else if (['warn', 'error'].indexOf(this.options.onStabilityMissing) >= 0) {\n          this.diagnostics.push({\n            type: this.options.onStabilityMissing,\n            message: createErrorMessage(\n                decl, `No stability annotation found for symbol \"${symbol.name}\"`)\n          });\n        }\n\n        output += stripEmptyLines(this.emitNode(decl)) + '\\n';\n      } else {\n        // This may happen for symbols re-exported from external modules.\n        this.diagnostics.push({\n          type: 'warning',\n          message:\n              createErrorMessage(decl, `No export declaration found for symbol \"${symbol.name}\"`)\n        });\n      }\n    }\n\n    if (this.diagnostics.length) {\n      const message = this.diagnostics.map(d => d.message).join('\\n');\n      console.warn(message);\n      if (this.diagnostics.some(d => d.type === 'error')) {\n        throw new Error(message);\n      }\n    }\n\n    return output;\n  }\n\n  private getResolvedSymbols(sourceFile: ts.SourceFile): ts.Symbol[] {\n    const ms = (<any>sourceFile).symbol;\n    const rawSymbols = ms ? (this.typeChecker.getExportsOfModule(ms) || []) : [];\n    return rawSymbols.map(s => {\n      if (s.flags & ts.SymbolFlags.Alias) {\n        const resolvedSymbol = this.typeChecker.getAliasedSymbol(s);\n\n        // This will happen, e.g. for symbols re-exported from external modules.\n        if (!resolvedSymbol.valueDeclaration && !resolvedSymbol.declarations) {\n          return s;\n        }\n        if (resolvedSymbol.name !== s.name) {\n          if (this.options.stripExportPattern && s.name.match(this.options.stripExportPattern)) {\n            return s;\n          }\n          throw new Error(\n              `Symbol \"${resolvedSymbol.name}\" was aliased as \"${s.name}\". ` +\n              `Aliases are not supported.\"`);\n        }\n\n        return resolvedSymbol;\n      } else {\n        return s;\n      }\n    });\n  }\n\n  emitNode(node: ts.Node) {\n    if (node.flags & ts.NodeFlags.Private) {\n      return '';\n    }\n\n    const firstQualifier: ts.Identifier = getFirstQualifier(node);\n\n    if (firstQualifier) {\n      if (!this.options.allowModuleIdentifiers ||\n          this.options.allowModuleIdentifiers.indexOf(firstQualifier.text) < 0) {\n        this.diagnostics.push({\n          type: 'error',\n          message: createErrorMessage(\n              firstQualifier,\n              `Module identifier \"${firstQualifier.text}\" is not allowed. Remove it ` +\n                  `from source or whitelist it via --allowModuleIdentifiers.`)\n        });\n      }\n    }\n\n    let children = node.getChildren();\n    const sourceText = node.getSourceFile().text;\n    if (children.length) {\n      // Sort declarations under a class or an interface\n      if (node.kind === ts.SyntaxKind.SyntaxList) {\n        switch (node.parent && node.parent.kind) {\n          case ts.SyntaxKind.ClassDeclaration:\n          case ts.SyntaxKind.InterfaceDeclaration: {\n            // There can be multiple SyntaxLists under a class or an interface,\n            // since SyntaxList is just an arbitrary data structure generated\n            // by Node#getChildren(). We need to check that we are sorting the\n            // right list.\n            if (children.every(node => node.kind in memberDeclarationOrder)) {\n              children = children.slice();\n              children.sort((a: ts.Declaration, b: ts.Declaration) => {\n                // Static after normal\n                return compareFunction(\n                           a.flags & ts.NodeFlags.Static, b.flags & ts.NodeFlags.Static) ||\n                    // Our predefined order\n                    compareFunction(\n                           memberDeclarationOrder[a.kind], memberDeclarationOrder[b.kind]) ||\n                    // Alphebetical order\n                    // We need safe dereferencing due to edge cases, e.g. having two call signatures\n                    compareFunction((a.name || a).getText(), (b.name || b).getText());\n              });\n            }\n            break;\n          }\n        }\n      }\n\n      let output = children.map(n => this.emitNode(n)).join('');\n\n      // Print stability annotation for fields\n      if (node.kind in memberDeclarationOrder) {\n        const trivia = sourceText.substr(node.pos, node.getLeadingTriviaWidth());\n        const match = stabilityAnnotationPattern.exec(trivia);\n        if (match) {\n          // Add the annotation after the leading whitespace\n          output = output.replace(/^(\\n\\s*)/, `$1/** @${match[1]} */ `);\n        }\n      }\n\n      return output;\n    } else {\n      const ranges = ts.getLeadingCommentRanges(sourceText, node.pos);\n      let tail = node.pos;\n      for (const range of ranges || []) {\n        if (range.end > tail) {\n          tail = range.end;\n        }\n      }\n      return sourceText.substring(tail, node.end);\n    }\n  }\n}\n\nfunction symbolCompareFunction(a: ts.Symbol, b: ts.Symbol) {\n  return a.name.localeCompare(b.name);\n}\n\nfunction compareFunction<T>(a: T, b: T) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\n\nconst memberDeclarationOrder = {\n  [ts.SyntaxKind.PropertySignature]: 0,\n  [ts.SyntaxKind.PropertyDeclaration]: 0,\n  [ts.SyntaxKind.GetAccessor]: 0,\n  [ts.SyntaxKind.SetAccessor]: 0,\n  [ts.SyntaxKind.CallSignature]: 1,\n  [ts.SyntaxKind.Constructor]: 2,\n  [ts.SyntaxKind.ConstructSignature]: 2,\n  [ts.SyntaxKind.IndexSignature]: 3,\n  [ts.SyntaxKind.MethodSignature]: 4,\n  [ts.SyntaxKind.MethodDeclaration]: 4\n};\n\nconst stabilityAnnotationPattern = /@(experimental|stable|deprecated)\\b/;\n\nfunction stripEmptyLines(text: string): string {\n  return text.split('\\n').filter(x => !!x.length).join('\\n');\n}\n\n/**\n * Returns the first qualifier if the input node is a dotted expression.\n */\nfunction getFirstQualifier(node: ts.Node): ts.Identifier {\n  if (node.kind === ts.SyntaxKind.PropertyAccessExpression) {\n    // For expression position\n    let lhs: ts.Node = node;\n    do {\n      lhs = (<ts.PropertyAccessExpression>lhs).expression;\n    } while (lhs && lhs.kind !== ts.SyntaxKind.Identifier);\n\n    return <ts.Identifier>lhs;\n\n  } else if (node.kind === ts.SyntaxKind.TypeReference) {\n    // For type position\n    let lhs: ts.Node = (<ts.TypeReferenceNode>node).typeName;\n    do {\n      lhs = (<ts.QualifiedName>lhs).left;\n    } while (lhs && lhs.kind !== ts.SyntaxKind.Identifier);\n\n    return <ts.Identifier>lhs;\n\n  } else {\n    return null;\n  }\n}\n\nfunction createErrorMessage(node: ts.Node, message: string): string {\n  const sourceFile = node.getSourceFile();\n  let position;\n  if (sourceFile) {\n    const {line, character} = sourceFile.getLineAndCharacterOfPosition(node.getStart());\n    position = `${sourceFile.fileName}(${line + 1},${character + 1})`;\n  } else {\n    position = '<unknown>';\n  }\n\n  return `${position}: error: ${message}`;\n}\n"]}